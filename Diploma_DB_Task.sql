
IF OBJECT_ID('PURCHASEORDER1522') IS NOT NULL
DROP TABLE PURCHASEORDER1522;

IF OBJECT_ID('INVENTORY1522') IS NOT NULL
DROP TABLE INVENTORY1522;

IF OBJECT_ID('ORDERLINE1522') IS NOT NULL
DROP TABLE ORDERLINE1522;

IF OBJECT_ID('ORDER1522') IS NOT NULL
DROP TABLE [ORDER1522];

IF OBJECT_ID('AUTHORISEDPERSON1522') IS NOT NULL
DROP TABLE AUTHORISEDPERSON1522;

IF OBJECT_ID('ACCOUNTPAYMENT1522') IS NOT NULL
DROP TABLE ACCOUNTPAYMENT1522;

IF OBJECT_ID('CLIENTACCOUNT1522') IS NOT NULL
DROP TABLE CLIENTACCOUNT1522;

IF OBJECT_ID('PRODUCT1522') IS NOT NULL
DROP TABLE PRODUCT1522;

IF OBJECT_ID('LOCATION1522') IS NOT NULL
DROP TABLE [LOCATION1522];

IF OBJECT_ID('GENERALLEDGER1522') IS NOT NULL
DROP TABLE GENERALLEDGER1522;

GO

CREATE TABLE GENERALLEDGER1522(
    ITEMID INTEGER,
    DESCRIPTION NVARCHAR(100),
    AMOUNT MONEY,
    CONSTRAINT PK_GENERALLEDGER PRIMARY KEY (ITEMID),
    CONSTRAINT UQ_GENERALEDGER_DESCRIPTION UNIQUE(DESCRIPTION)
);

INSERT INTO GENERALLEDGER1522 (ITEMID, DESCRIPTION, AMOUNT) VALUES
(1, 'ASSETSCASH', 100000.00),
(2, 'ASSETSSTOCK', 0),
(3, 'ASSETSACCOUNT', 0);

CREATE TABLE [LOCATION1522](
    LOCATIONID NVARCHAR(8),
    LOCNAME NVARCHAR(50) NOT NULL,
    ADDRESS NVARCHAR(200) NOT NULL,
    MANAGER NVARCHAR(100),
    CONSTRAINT PK_LOCATION PRIMARY KEY (LOCATIONID)
);

CREATE TABLE PRODUCT1522(
    PRODUCTID INTEGER IDENTITY(10001, 1),
    PRODNAME NVARCHAR(100) NOT NULL,
    BUYPRICE MONEY,
    SELLPRICE MONEY,
    CONSTRAINT PK_PRODUCT PRIMARY KEY(PRODUCTID),
    CONSTRAINT CHK_WHOLESALE_RETAIL CHECK(BUYPRICE < SELLPRICE)
);

CREATE TABLE CLIENTACCOUNT1522(
    ACCOUNTID INTEGER IDENTITY(30001, 1),
    ACCTNAME NVARCHAR(100) NOT NULL,
    BALANCE MONEY NOT NULL,
    CREDITLIMIT MONEY NOT NULL,
    CONSTRAINT PK_CLIENTACCOUNT PRIMARY KEY(ACCOUNTID),
    CONSTRAINT CHK_CLIENTACCOUNT_BALANCE_CREDIT CHECK(BALANCE<=CREDITLIMIT),
    CONSTRAINT UQ_CLENTACCOUNT_NAME UNIQUE(ACCTNAME)
);


CREATE TABLE ACCOUNTPAYMENT1522(
    ACCOUNTID INTEGER,
    DATETIMERECEIVED DATETIME,
    AMOUNT MONEY NOT NULL,
    CONSTRAINT PK_ACCOUNTPAYMENT PRIMARY KEY(ACCOUNTID, DATETIMERECEIVED),
    CONSTRAINT FK_ACCOUNTPAYMENT_ACCOUNT FOREIGN KEY (ACCOUNTID) REFERENCES CLIENTACCOUNT1522,
    CONSTRAINT CHK_ACCOUNTPAYMENT_AMOUNT CHECK(AMOUNT >0)
);

CREATE TABLE AUTHORISEDPERSON1522(
    USERID INTEGER IDENTITY(50001, 1),
    FIRSTNAME NVARCHAR(100) NOT NULL,
    SURNAME NVARCHAR(100) NOT NULL,
    EMAIL NVARCHAR(100) NOT NULL,
    [PASSWORD] NVARCHAR(100) NOT NULL,
    ACCOUNTID INTEGER NOT NULL,
    CONSTRAINT PK_AUTHORISEDPERSON PRIMARY KEY(USERID),
    CONSTRAINT FK_AUTHORISEDPERSON_CLIENTACCOUNT FOREIGN KEY(ACCOUNTID) REFERENCES CLIENTACCOUNT1522,
    CONSTRAINT CHK_AUTHORISEDPERSON_EMAIL CHECK(EMAIL LIKE '%@%')
);

CREATE TABLE [ORDER1522](
    ORDERID INTEGER IDENTITY(70001, 1),
    SHIPPINGADDRESS NVARCHAR(200) NOT NULL,
    DATETIMECREATED DATETIME NOT NULL,
    DATETIMEDISPATCHED DATETIME,
    TOTAL MONEY NOT NULL,
    USERID INTEGER NOT NULL,
    CONSTRAINT PK_ORDER PRIMARY KEY(ORDERID),
    CONSTRAINT FK_ORDER_AUTHORISEDPERSON FOREIGN KEY(USERID) REFERENCES AUTHORISEDPERSON1522,
    CONSTRAINT CHK_ORDER_TOTAL CHECK(TOTAL >= 0)
);


CREATE TABLE ORDERLINE1522(
    ORDERID INTEGER,
    PRODUCTID INT,
    QUANTITY INT NOT NULL,
    DISCOUNT DECIMAL(3,2) DEFAULT 0,
    SUBTOTAL MONEY NOT NULL,
    CONSTRAINT PK_ORDERLINE PRIMARY KEY(ORDERID, PRODUCTID),
    CONSTRAINT FK_ORDERLINE_ORDER FOREIGN KEY(ORDERID) REFERENCES [ORDER1522],
    CONSTRAINT FK_ORDERLINE_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT1522,
    CONSTRAINT CHK_ORDER_DISCOUNT CHECK(DISCOUNT >=0 AND DISCOUNT <= 0.25),
    CONSTRAINT CHK_ORDERLINE_SUBTOTAL CHECK(SUBTOTAL > 0)
);

CREATE TABLE INVENTORY1522(
    PRODUCTID INT,
    LOCATIONID NVARCHAR(8),
    NUMINSTOCK INTEGER NOT NULL,
    CONSTRAINT PK_INVENTORY PRIMARY KEY(PRODUCTID, LOCATIONID),
    CONSTRAINT FK_INVENTORY_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT1522,
    CONSTRAINT FK_INVENTORY_LOCATION FOREIGN KEY(LOCATIONID) REFERENCES LOCATION1522,
    CONSTRAINT CHK_INVENTORY_NUMINSTOCK CHECK(NUMINSTOCK >=0)
);

CREATE TABLE PURCHASEORDER1522(
    PRODUCTID INT,
    LOCATIONID NVARCHAR(8),
    DATETIMECREATED DATETIME,
    QUANTITY INTEGER,
    TOTAL MONEY,
    CONSTRAINT PK_PURCHASEORDER PRIMARY KEY(PRODUCTID, LOCATIONID, DATETIMECREATED),
    CONSTRAINT FK_PURCHASEORDER_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT1522,
    CONSTRAINT FK_PURCHASEORDER_LOCATION FOREIGN KEY(LOCATIONID) REFERENCES LOCATION1522,
    CONSTRAINT CHK_PURCHASEORDER_QUANTITY CHECK(QUANTITY > 0)
);

GO


--SELECT * FROM SYS.TABLES;

--------------------------

-- SET UP LOCATION, PRODUCT AND INVENTORY
BEGIN

    INSERT INTO LOCATION1522(LOCATIONID, LOCNAME, ADDRESS, MANAGER)VALUES
    ('MLB3931', 'Melbourne South East', '123 Demon Street, Mornington, 3931', 'Bruce Wayne');

    INSERT INTO PRODUCT1522(PRODNAME, BUYPRICE, SELLPRICE) VALUES
    ('APPLE ME PHONE X', '890.00', 1295.00 );

    DECLARE @PRODID INT = @@IDENTITY;

    INSERT INTO INVENTORY1522(PRODUCTID, LOCATIONID, NUMINSTOCK) VALUES
    (@PRODID, 'MLB3931', 0);

    -- ADD A NEW CLIENT ACCOUNT AND A NEW AUTHORISED USER FOR THAT ACCOUNT

    INSERT INTO CLIENTACCOUNT1522(ACCTNAME, BALANCE, CREDITLIMIT) VALUES
    ('FREDS LOCAL PHONE STORE', '0', 10000.00 );

    DECLARE @ACCOUNTID INT = @@IDENTITY;

    INSERT INTO AUTHORISEDPERSON1522(FIRSTNAME, SURNAME, EMAIL, [PASSWORD], ACCOUNTID) VALUES
    ('Fred', 'Flintstone', 'fred@fredsphones.com', 'secret', @ACCOUNTID);

    DECLARE @USERID INT = @@IDENTITY;

    -----------

    -- BUY SOME STOCK

    -- ADD A PURCHASE ORDER ROW
    INSERT INTO PURCHASEORDER1522(PRODUCTID, LOCATIONID, DATETIMECREATED, QUANTITY, TOTAL) VALUES
    (@PRODID,  'MLB3931', '10-Apr-2020', 50, 44500.00);

    -- UPDATE OUR INVENTORY FOR THAT STOCK
    UPDATE INVENTORY1522 SET NUMINSTOCK = 50 WHERE PRODUCTID = @PRODID AND LOCATIONID = 'MLB3931';

    -- UPDATE THE GENERAL LEDGER INCREASING THE VALUE OF OUR STOCK ASSETS AND DECREASING THE CASH ASSETS
    UPDATE GENERALLEDGER1522 SET AMOUNT = AMOUNT - 44500.00 WHERE DESCRIPTION = 'ASSETSCASH';
    UPDATE GENERALLEDGER1522 SET AMOUNT = AMOUNT + 44500.00 WHERE DESCRIPTION = 'ASSETSSTOCK';

    -----------

    -- CUSTOMER MAKES AN ORDER - (INITIALLY THE ORDER IS NOT FULFILLED)

    INSERT INTO ORDER1522(SHIPPINGADDRESS, DATETIMECREATED, DATETIMEDISPATCHED, TOTAL, USERID) VALUES
    ('7 Lucky Strike, Bedrock, USB, 1111', '20-Apr-2020', NULL, 6151.25, @USERID);

    DECLARE @ORDERID INT = @@IDENTITY;

    INSERT INTO ORDERLINE1522(ORDERID, PRODUCTID, QUANTITY, DISCOUNT, SUBTOTAL) VALUES
    (@ORDERID, @PRODID, 5, 0.05, '6151.25');

    -- WE FULLFILL THE ORDER

    -- UPDATE THE ORDER TO GIVE IT A FULLFUILLED DATE
    UPDATE ORDER1522 SET DATETIMEDISPATCHED = '21-Apr-2020' WHERE ORDERID = @ORDERID;

    -- UPDATE THE CLIENTS ACCOUNT BALANCE TO INCLUDE THE VALUE OF THE ORDER
    UPDATE CLIENTACCOUNT1522 SET BALANCE = BALANCE + 6151.25 WHERE ACCOUNTID = @ACCOUNTID;

    -- UPDATE THE GENERAL LEDGER INCREASING VALUE OF ACCOUNTS, DECEASING VALUE OF STOCK
    UPDATE GENERALLEDGER1522 SET AMOUNT = AMOUNT + 6151.25  WHERE DESCRIPTION = 'ASSETSACCOUNT';
    UPDATE GENERALLEDGER1522 SET AMOUNT = AMOUNT - (5*890) WHERE DESCRIPTION = 'ASSETSSTOCK';

    -------------

    -- CLIENT MAKES AN ACCOUNT OFF THIER ACCOUNT BALANCE

    -- ADD A ROW TO ACCOUNTPAYMENT1522
    INSERT INTO ACCOUNTPAYMENT1522(ACCOUNTID, DATETIMERECEIVED, AMOUNT) VALUES
        (@ACCOUNTID, '25-Apr-2020', '2000.00');

    -- UPDATE THE CLIENT ACCOUNT TO REFLECT THE BALANCE CHANGE
    UPDATE CLIENTACCOUNT1522 SET BALANCE = BALANCE - 2000.00 WHERE ACCOUNTID = @ACCOUNTID;

    -- UPDATE THE GENERAL LEDGER - INCREASE ASSETSCASH AND DECREASE ASSETS ACCOUNT
    UPDATE GENERALLEDGER1522 SET AMOUNT = AMOUNT + 2000.00 WHERE DESCRIPTION = 'ASSETSCASH';
    UPDATE GENERALLEDGER1522 SET AMOUNT = AMOUNT - 2000.00 WHERE DESCRIPTION = 'ASSETSACCOUNT';
END;

GO
-----------------------------------------------------------------------------

GO
IF OBJECT_ID('ADD_LOCATION') IS NOT NULL
DROP PROCEDURE ADD_LOCATION;
GO


CREATE PROCEDURE ADD_LOCATION @PLOCID NVARCHAR(8), @PLOCNAME NVARCHAR(50), @PLOCADDRESS NVARCHAR(200), @PMANAGER NVARCHAR(100) AS 
 BEGIN
  BEGIN TRY
  BEGIN TRANSACTION
   INSERT INTO LOCATION1522(LOCATIONID,LOCNAME,[ADDRESS],MANAGER) VALUES(@PLOCID,@PLOCNAME,@PLOCADDRESS,@PMANAGER);
    DECLARE @PRODUCTID INT;
    DECLARE @ProductIDCursor CURSOR;
    SET @ProductIDCursor = CURSOR FOR SELECT PRODUCTID FROM PRODUCT1522;
    OPEN @ProductIDCursor;
      FETCH NEXT FROM @ProductIDCursor INTO @PRODUCTID;
      WHILE @@FETCH_STATUS = 0
         BEGIN
           INSERT INTO INVENTORY1522(PRODUCTID,LOCATIONID,NUMINSTOCK) VALUES(@PRODUCTID,@PLOCID,0)
           FETCH NEXT FROM @ProductIDCursor INTO @PRODUCTID;     
         END   
      CLOSE @ProductIDCursor;     
      DEALLOCATE @ProductIDCursor;
     COMMIT TRANSACTION
  END TRY

 BEGIN CATCH
  ROLLBACK TRANSACTION;
 if ERROR_NUMBER() = 2627            
   THROW 51001, 'DUPLICATE LOCATION ID', 1             
    ELSE           
    BEGIN                
    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
    THROW 50000, @ERRORMESSAGE,1            
    END;    
 END CATCH
-----------------------------------------------------------------------------

 
END;
GO
   EXEC ADD_LOCATION @PLOCID = '1',@PLOCNAME = 'Swinburne',@PLOCADDRESS = 'Hawthorn', @PMANAGER = 'Teacher'; 
GO


-----------------------------------------------------------------------------
IF OBJECT_ID('GET_LOCATION_BY_ID') IS NOT NULL
DROP PROCEDURE GET_LOCATION_BY_ID ;
GO


CREATE PROCEDURE GET_LOCATION_BY_ID @PLOCID NVARCHAR(8)  AS
BEGIN
 BEGIN TRY
  IF EXISTS (SELECT * FROM LOCATION1522 WHERE LOCATIONID = @PLOCID)
  BEGIN     
  SELECT * FROM LOCATION1522 WHERE LOCATIONID = @PLOCID 
  END 
 ELSE 
  THROW 51002,'LOCATION DOES NOT EXIST',1
 END TRY
 BEGIN CATCH
  IF ERROR_NUMBER() = 51002
  THROW
  ELSE        
    BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
    END;  
 END CATCH
END;
-------------------------------------------------------------------------------------------------
GO
 BEGIN
  EXEC GET_LOCATION_BY_ID @PLOCID = '1';
  END;
------------------------------------------------------------------------------------------------
GO
IF OBJECT_ID('ADD_PRODUCT') IS NOT NULL
DROP PROCEDURE ADD_PRODUCT ;
GO


CREATE PROCEDURE ADD_PRODUCT @PPRODNAME NVARCHAR(100), @PBUYPRICE MONEY, @PSELLPRICE MONEY AS
BEGIN
 BEGIN TRY
  BEGIN TRANSACTION
   INSERT INTO PRODUCT1522(PRODNAME,BUYPRICE,SELLPRICE) VALUES(@PPRODNAME,@PBUYPRICE,@PSELLPRICE);
   DECLARE @PRODUCTID INT,@LOCID NVARCHAR(8);
   SET @PRODUCTID = (SELECT max(PRODUCTID) FROM PRODUCT1522);
     DECLARE @LocationIDCursor CURSOR;
     SET @LocationIDCursor = CURSOR FOR SELECT LOCATIONID FROM LOCATION1522;
     OPEN @LocationIDCursor;
       FETCH NEXT FROM @LocationIDCursor INTO @LOCID;
       WHILE @@FETCH_STATUS = 0
          BEGIN
            INSERT INTO INVENTORY1522(PRODUCTID,LOCATIONID,NUMINSTOCK) VALUES(@PRODUCTID,@LOCID,0)
            FETCH NEXT FROM @LocationIDCursor INTO @LOCID;     
          END   
       CLOSE @LocationIDCursor;     
       DEALLOCATE @LocationIDCursor;
     COMMIT TRANSACTION
     RETURN @PRODUCTID
  END TRY
 BEGIN CATCH
  ROLLBACK TRANSACTION;              
    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
    THROW 50000, @ERRORMESSAGE,1            
 END CATCH
END;


------------------------------------------------------------------------------------------

GO

EXEC ADD_PRODUCT @PPRODNAME = 'Product',@PBUYPRICE = 10,@PSELLPRICE = 15;

GO

------------------------------------------------------------------------------------------

IF OBJECT_ID('GET_PRODUCT_BY_ID') IS NOT NULL
DROP PROCEDURE GET_PRODUCT_BY_ID ;
GO


CREATE PROCEDURE GET_PRODUCT_BY_ID @PPRODID INT AS
BEGIN
 BEGIN TRY
  IF EXISTS (SELECT * FROM PRODUCT1522 WHERE PRODUCTID = @PPRODID)
  BEGIN  
   SELECT * FROM PRODUCT1522 WHERE PRODUCTID = @PPRODID
  END 
 ELSE 
  THROW 52002,'PRODUCT DOES NOT EXIST',1
 END TRY
 BEGIN CATCH
  IF ERROR_NUMBER() = 52002
  THROW
  ELSE        
    BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
    END;  
 END CATCH
END;

-------------------------------------------------------------------------------------------
GO

  EXEC GET_PRODUCT_BY_ID @PPRODID = 10001;

-------------------------------------------------------------------------------------------

GO
IF OBJECT_ID('PURCHASE_STOCK') IS NOT NULL
DROP PROCEDURE PURCHASE_STOCK;
GO

CREATE PROCEDURE PURCHASE_STOCK @PPRODID INT, @PLOCID NVARCHAR(8), @PQTY INT AS
BEGIN
 BEGIN TRY
 BEGIN TRANSACTION
 
 IF NOT EXISTS (SELECT * FROM LOCATION1522 WHERE LOCATIONID = @PLOCID)
  THROW 51002,'LOCATION DOES NOT EXIST',1
 IF NOT EXISTS (SELECT * FROM PRODUCT1522 WHERE PRODUCTID = @PPRODID)
  THROW 52002,'PRODUCT DOES NOT EXIST',1
 DECLARE @TOTAL MONEY,@BUYPRICE MONEY;
 SET @BUYPRICE = (SELECT BUYPRICE FROM PRODUCT1522 WHERE PRODUCTID = @PPRODID);
 SET @TOTAL = @BUYPRICE * @PQTY
 IF (SELECT AMOUNT FROM GENERALLEDGER1522 WHERE [ITEMID] = 1) < @TOTAL
  THROW 59001,'INSUFFIECIENT CASH',1 
 INSERT INTO PURCHASEORDER1522(PRODUCTID,LOCATIONID,DATETIMECREATED,QUANTITY,TOTAL) VALUES(@PPRODID,@PLOCID,GETDATE(),@PQTY,@TOTAL)
 SELECT * FROM INVENTORY1522
    UPDATE INVENTORY1522
    SET NUMINSTOCK = NUMINSTOCK + @PQTY
    WHERE LOCATIONID = @PLOCID AND PRODUCTID = @PPRODID
    UPDATE GENERALLEDGER1522
    SET AMOUNT = AMOUNT - @TOTAL
    WHERE [ITEMID] = 1
    UPDATE GENERALLEDGER1522
    SET AMOUNT = AMOUNT + @TOTAL
    WHERE [ITEMID] = 2
 COMMIT TRANSACTION
 END TRY
 BEGIN CATCH 
 ROLLBACK TRANSACTION
 IF ERROR_NUMBER() = 51002 OR ERROR_NUMBER() = 52002 OR ERROR_NUMBER() = 59001
 THROW
 ELSE
    BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
    END; 
 END CATCH
END;
------------------------------------------------------------------------------

GO

 EXEC PURCHASE_STOCK @PPRODID = 10002,@PLOCID = '1',@PQTY = 10


GO

------------------------------------------------------------------------------

IF OBJECT_ID('ADD_CLIENT_ACCOUNT') IS NOT NULL
DROP PROCEDURE ADD_CLIENT_ACCOUNT;
GO


CREATE PROCEDURE ADD_CLIENT_ACCOUNT @PACCTNAME NVARCHAR(100), @PBALANCE MONEY, @PCREDITLIMIT MONEY AS
BEGIN
 BEGIN TRY
 INSERT INTO CLIENTACCOUNT1522(ACCTNAME,BALANCE,CREDITLIMIT) VALUES(@PACCTNAME,@PBALANCE,@PCREDITLIMIT)
 RETURN @@IDENTITY
 END TRY
 BEGIN CATCH
 IF ERROR_MESSAGE() LIKE '%UQ_CLENTACCOUNT_NAME%'
  THROW 53001,'DUPLICATE ACCOUNT NAME',1
 ELSE
  BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
  END; 
 END CATCH
END;
-----------------------------------------------------------------------------------
GO

EXEC ADD_CLIENT_ACCOUNT @PACCTNAME = 'neW',@PBALANCE = 0,@PCREDITLIMIT = 0

-----------------------------------------------------------------------------------

GO

IF OBJECT_ID('ADD_AUTHORISED_PERSON') IS NOT NULL
DROP PROCEDURE ADD_AUTHORISED_PERSON;

GO


CREATE PROCEDURE ADD_AUTHORISED_PERSON @PFIRSTNAME NVARCHAR(100), @PSURNAME NVARCHAR(100), @PEMAIL NVARCHAR(100), @PPASSWORD NVARCHAR(100), @PACCOUNTID INT AS
BEGIN
BEGIN TRY
IF NOT @PEMAIL LIKE '%@%'
 THROW 53003,'INVALID EMAIL ADDRESS',1
INSERT INTO AUTHORISEDPERSON1522(FIRSTNAME,SURNAME,EMAIL,[PASSWORD],ACCOUNTID) VALUES(@PFIRSTNAME,@PSURNAME,@PEMAIL,@PPASSWORD,@PACCOUNTID)
RETURN @@IDENTITY
END TRY
BEGIN CATCH
IF ERROR_NUMBER() = 53003
 THROW
ELSE
  BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
  END;  
END CATCH
END;

------------------------------------------------------------------------------------
GO

EXEC ADD_AUTHORISED_PERSON @PFIRSTNAME = "testdude",@PSURNAME = 'testdude',@PEMAIL = '1234@RUBBISHMAIL.COM.AU',@PPASSWORD = 'THE PASSWORD',@PACCOUNTID = 30002

GO
------------------------------------------------------------------------------------

IF OBJECT_ID('MAKE_ACCOUNT_PAYMENT') IS NOT NULL
DROP PROCEDURE MAKE_ACCOUNT_PAYMENT;

GO

------------------------------------------------------------------------------------


CREATE PROCEDURE MAKE_ACCOUNT_PAYMENT @PACCOUNTID INT, @PAMOUNT MONEY AS
BEGIN
 BEGIN TRY
  BEGIN TRANSACTION
   IF NOT EXISTS (SELECT * FROM CLIENTACCOUNT1522 WHERE ACCOUNTID = @PACCOUNTID)
    THROW 53002,'ACCOUNT DOES NOT EXIST',1
   IF @PAMOUNT <= 0
    THROW 53004,'ACCOUNT PAYMENT AMOUNT MUST BE POSITIVE',1
  INSERT INTO ACCOUNTPAYMENT1522(ACCOUNTID,DATETIMERECEIVED,AMOUNT) VALUES(@PACCOUNTID,GETDATE(),@PAMOUNT)
  UPDATE CLIENTACCOUNT1522
  SET BALANCE = BALANCE - @PAMOUNT
  WHERE ACCOUNTID = @PACCOUNTID
  UPDATE GENERALLEDGER1522
    SET AMOUNT = AMOUNT - @PAMOUNT
    WHERE [ITEMID] = 1
    UPDATE GENERALLEDGER1522
    SET AMOUNT = AMOUNT + @PAMOUNT
    WHERE [ITEMID] = 2
  COMMIT TRANSACTION
 END TRY
 BEGIN CATCH
 ROLLBACK TRANSACTION;
 IF ERROR_NUMBER() = 53002
  THROW
 IF ERROR_NUMBER() = 53004
  THROW
 ELSE 
    BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
    END;  
 END CATCH

    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- insert the specified values into the table ACCOUNTPAYMENT1522 (USING THE CURRENT SYS DATETIME)
    -- UPDATE THE RELEVANT ACCOUNT IN CLENTACCOUNT1522 TO RELFECT THE BALANCE REDUCED BY THE PAYMENT
    -- UPDATE THE GENERAL LEDGER TO REDUCE ACCOUNT ASSETS BY THE PAYMENT AMOUNT
    -- UPDATE THE GENERAL LEDGER TO INCREASE CASH ASSETS BY THE PAYMENT AMOUNT

    -- EXCEPTIONS
    -- ACCOUNT DOESNT EXIST THROW ERROR 53002 : ACCOUNT DOES NOT EXIST 
    -- PAYMENT AMOUNT IS NEGATIVE (SEE TABLE CONSTRAINTS) THROW ERROR 53004 :   ACCOUNT PAYMENT AMOUNT MUST BE POSITIVE  
    -- for any other errors throw error : number 50000  message:  error_message()
END;

-------------------------------------------------------------------------------------------------

GO
EXEC MAKE_ACCOUNT_PAYMENT @PACCOUNTID = 30001,@PAMOUNT = 10
GO 

--------------------------------------------------------------------------------------------------

IF OBJECT_ID('GET_CLIENT_ACCOUNT_BY_ID') IS NOT NULL
DROP PROCEDURE GET_CLIENT_ACCOUNT_BY_ID;

GO

CREATE PROCEDURE GET_CLIENT_ACCOUNT_BY_ID @PACCOUNTID INT AS
BEGIN
 BEGIN TRY
 IF NOT EXISTS (SELECT * FROM CLIENTACCOUNT1522 WHERE ACCOUNTID = @PACCOUNTID)
  THROW 53002,'ACCOUNT DOES NOT EXIST',1
 ELSE
  BEGIN
 SELECT C.ACCOUNTID,C.ACCTNAME,C.BALANCE,C.CREDITLIMIT,A.USERID,A.FIRSTNAME,A.SURNAME,A.EMAIL,A.[PASSWORD] FROM CLIENTACCOUNT1522 C INNER JOIN AUTHORISEDPERSON1522 A ON C.ACCOUNTID = A.ACCOUNTID WHERE C.ACCOUNTID = @PACCOUNTID       
  END
 END TRY
 BEGIN CATCH
 IF ERROR_NUMBER() = 53002
  THROW
 ELSE
  BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
  END;  
 END CATCH

    -- return the specified CLIENT ACCOUNT INCLUDING AND ALL AUTHORISED PERSONS DETAILS

    -- EXCEPTIONS
     -- ACCOUNT DOESNT EXIST THROW ERROR 53002 : ACCOUNT DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()
END;
GO

---------------------------------------------------------------------------------------------------
GO

  EXEC GET_CLIENT_ACCOUNT_BY_ID  @PACCOUNTID = 30001;
  
---------------------------------------------------------------------------------------------------

GO
IF OBJECT_ID('CREATE_ORDER') IS NOT NULL
DROP PROCEDURE CREATE_ORDER;
GO


CREATE PROCEDURE CREATE_ORDER  @PSHIPPINGADDRESS NVARCHAR(200), @PUSERID INT AS
BEGIN
 BEGIN TRY
  IF NOT EXISTS (SELECT * FROM AUTHORISEDPERSON1522 WHERE USERID = @PUSERID)
   THROW 55002,'USER DOES NOT EXIST',1
  INSERT INTO ORDER1522(SHIPPINGADDRESS,DATETIMECREATED,DATETIMEDISPATCHED,TOTAL,USERID) VALUES(@PSHIPPINGADDRESS,GETDATE(),NULL,0,@PUSERID)
  RETURN @@IDENTITY
 END TRY
 BEGIN CATCH
  IF ERROR_NUMBER() = 55002
   THROW
  ELSE 
  BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
  END;
 END CATCH
    -- insert the specified values into the table ORDER1522
    -- SET THE TOTAL TO 0
    -- RETURN THE NEW ORDERS ORDERID

    -- EXCEPTIONS
    -- USER DOES NOT EXIST : THROW ERROR 55002 : USER DOES NOT EXIST
    -- for any other errors throw error : number 50000  message:  error_message()
END;
GO

-------------------------------------------------------------------------------------------

EXEC CREATE_ORDER @PSHIPPINGADDRESS = '1234 swinburne street hawthorn',@PUSERID = 50002

GO
-------------------------------------------------------------------------------------------

IF OBJECT_ID('GET_ORDER_BY_ID') IS NOT NULL
DROP PROCEDURE GET_ORDER_BY_ID;

GO

CREATE PROCEDURE GET_ORDER_BY_ID @PORDERID INT AS
BEGIN
 BEGIN TRY
  IF NOT EXISTS (SELECT * FROM ORDER1522 WHERE ORDERID = @PORDERID)
   THROW 54002,'ORDER DOES NOT EXIST',1
  ELSE
  BEGIN
   SELECT o.ORDERID,o.SHIPPINGADDRESS,o.DATETIMECREATED,o.DATETIMEDISPATCHED,o.TOTAL,o.USERID,ol.PRODUCTID,ol.QUANTITY,ol.DISCOUNT,ol.SUBTOTAL FROM ORDER1522 O INNER JOIN ORDERLINE1522 OL ON O.ORDERID = OL.ORDERID WHERE O.ORDERID = @PORDERID
  END
 END TRY
 BEGIN CATCH
  IF ERROR_NUMBER() = 54002
   THROW
  ELSE 
  BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000,@ERRORMESSAGE,1            
  END;
 END CATCH
    -- return the specified ORDER INCLUDING ALL RELATED ORDERLINES

    -- EXCEPTIONS
     -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()
END; 
-------------------------------------------------------------------------------------
GO
 
  EXEC GET_ORDER_BY_ID @PORDERID = 70002;
  
-------------------------------------------------------------------------------------
GO


IF OBJECT_ID('ADD_PRODUCT_TO_ORDER') IS NOT NULL
DROP PROCEDURE ADD_PRODUCT_TO_ORDER;
GO


CREATE PROCEDURE ADD_PRODUCT_TO_ORDER @PORDERID INT, @PPRODID INT, @PQTY INT, @DISCOUNT DECIMAL(3,2) AS
BEGIN
 BEGIN TRANSACTION 
  BEGIN TRY
    IF NOT EXISTS (SELECT * FROM ORDER1522 WHERE ORDERID = @PORDERID)
     THROW 54002,'ORDER DOES NOT EXIST',1
    IF NOT EXISTS (SELECT * FROM PRODUCT1522 WHERE PRODUCTID = @PPRODID)
     THROW 52002,'PRODUCT DOES NOT EXIST',1
    IF (SELECT DATETIMEDISPATCHED FROM ORDER1522 WHERE ORDERID = @PORDERID) IS NOT NULL
     THROW 54003,'ORDER HAS ALRADY BEEN FULLFILLED',1
    IF @DISCOUNT < 0 OR @DISCOUNT > 0.25
     THROW 54004,'DISCOUNT OUT OF RANGE',1
    DECLARE @SELLPRICE FLOAT
    SET @SELLPRICE = (SELECT SELLPRICE FROM PRODUCT1522 WHERE PRODUCTID = @PPRODID)
    DECLARE @SUBTOTAL MONEY;
    IF NOT EXISTS (SELECT * FROM ORDERLINE1522 WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODID)
     BEGIN
     SET @SUBTOTAL = (@SELLPRICE * @PQTY)
     SET @SUBTOTAL = @SUBTOTAL * (1 - @DISCOUNT)  
     INSERT INTO ORDERLINE1522(ORDERID,PRODUCTID,QUANTITY,DISCOUNT,SUBTOTAL) VALUES(@PORDERID,@PPRODID,@PQTY,@DISCOUNT,@SUBTOTAL)
     UPDATE ORDER1522
     SET TOTAL = TOTAL + @SUBTOTAL
     WHERE ORDERID = @PORDERID
     END
    ELSE
     BEGIN
      DECLARE @NEWQTY INT,
      @TOTALINCREASEAMOUNT MONEY;
      SET @TOTALINCREASEAMOUNT = (@SELLPRICE * @PQTY) * (1 - @DISCOUNT)
      UPDATE ORDERLINE1522
      SET QUANTITY = QUANTITY + @PQTY
      WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODID
      SET @NEWQTY = (SELECT QUANTITY FROM ORDERLINE1522 WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODID)
      SET @SUBTOTAL = @SELLPRICE * @NEWQTY
      SET @SUBTOTAL = @SUBTOTAL * (1 - @DISCOUNT)
      UPDATE ORDERLINE1522
      SET SUBTOTAL = @SUBTOTAL
      WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODID
      UPDATE ORDER1522
      SET TOTAL = TOTAL + @TOTALINCREASEAMOUNT
      WHERE ORDERID = @PORDERID
     END
  COMMIT TRANSACTION
  END TRY
  BEGIN CATCH
  ROLLBACK TRANSACTION
  IF ERROR_NUMBER() = 54002 OR ERROR_NUMBER() = 52002 OR ERROR_NUMBER() = 54003 OR ERROR_NUMBER() = 54004
   THROW
  ELSE           
    BEGIN                
    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
    THROW 50000, @ERRORMESSAGE,1            
    END;  
  END CATCH
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION
    -- IF IT HAS NOT BEEN FULLFILLED THEN
    -- IF THE PRODUCT HAS NOT ALREADY BEEN ADDED TO THAT ORDER (I.E. PK IS UNIQUE)
        -- insert the specified values into the table ORDERLINE1522
        -- CALCULATE THE SUBTOTAL VALUE BASED ON THE PRODUCTS SELLPRICE, THE QUANTITY AND THE DISCOUNT
        -- UPDATE THE ORDERS TOTAL - INCREASE IT BY THE VALUE OF THE ORDRLINES SUBTOTAL
    -- ELSE -- the product is aleady in that order 
        -- update the relevant orderline by adding the new quantity to the previous quantity,
        -- RE CALCULATE THE SUBTOTAL VALUE BASED ON THE PRODUCTS SELLPRICE, THE QUANTITY AND THE DISCOUNT
        -- UPDATE THE ORDERS TOTAL - INCREASE IT BY THE VALUE OF THE QTY ADDED TO THE ORDERLINE

    -- EXCEPTIONS
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54002 : ORDER HAS ALRADY BEEN FULLFILLED
    -- PRODUCT DOES NOT EXIST THROW ERROR 52002 : PRODUCT DOES NOT EXIST
    -- DISCOUNT IS OUT OF PERMITTED RANGE (SEE TABLE CONSTRAINTS) THROW ERROR 54004 : DISCOUNT OUT OF RANGE
    -- for any other errors throw error : number 50000  message:  error_message()
END;
GO

------------------------------------------------------------------------------------------

EXEC ADD_PRODUCT_TO_ORDER @PORDERID = 70002,@PPRODID = 10002,@PQTY = 5,@DISCOUNT = 0.25 

------------------------------------------------------------------------------------------

GO
IF OBJECT_ID('REMOVE_PRODUCT_FROM_ORDER') IS NOT NULL
DROP PROCEDURE REMOVE_PRODUCT_FROM_ORDER;
GO


CREATE PROCEDURE REMOVE_PRODUCT_FROM_ORDER @PORDERID INT, @PPRODID INT AS
BEGIN
 BEGIN TRANSACTION
  BEGIN TRY
  IF NOT EXISTS (SELECT * FROM ORDER1522 WHERE ORDERID = @PORDERID)
     THROW 54002,'ORDER DOES NOT EXIST',1
    IF NOT EXISTS (SELECT * FROM PRODUCT1522 WHERE PRODUCTID = @PPRODID)
     THROW 52002,'PRODUCT DOES NOT EXIST',1
    IF (SELECT DATETIMEDISPATCHED FROM ORDER1522 WHERE ORDERID = @PORDERID) IS NOT NULL
     THROW 54003,'ORDER HAS ALRADY BEEN FULLFILLED',1
    IF NOT EXISTS (SELECT * FROM ORDERLINE1522 WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODID)
     THROW 54005,'PRODUCT NOT ON ORDER',1
     DECLARE @SUBTOTAL MONEY;
     SET @SUBTOTAL = (SELECT SUBTOTAL FROM ORDERLINE1522 WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODID)
    UPDATE ORDER1522
    SET TOTAL = TOTAL - @SUBTOTAL
    WHERE ORDERID = @PORDERID
    DELETE FROM ORDERLINE1522 WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODID
  COMMIT TRANSACTION
  END TRY
  BEGIN CATCH
  IF ERROR_NUMBER() = 54002 OR ERROR_NUMBER() = 52002 OR ERROR_NUMBER() = 54003 OR ERROR_NUMBER() = 54005
   THROW
  ELSE           
    BEGIN                
    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
    THROW 50000, @ERRORMESSAGE,1            
    END;  
  END CATCH
    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION
    -- IF IT HAS NOT BEEN FULLFILLED THEN
    -- UPDATE THE ORDERS TOTAL - DECREASE IT BY THE VALUE OF THE ORDRLINES SUBTOTAL
    -- DELETE THE RELEVANT ROW FROM ORDERLINE1522

    -- EXCEPTIONS
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54002 : ORDER HAS ALREADY BEEN FULLFILLED
    -- PRODUCT DOES NOT EXIST THROW ERROR 52002 : PRODUCT DOES NOT EXIST
    -- PRODUCT HAS NOT BEEN ADDED TO ORDER THROW ERROR 54005 : PRODUCT NOT ON ORDER
    -- for any other errors throw error : number 50000  message:  error_message()
END;
GO
---------------------------------------------------------------------

EXEC REMOVE_PRODUCT_FROM_ORDER @PORDERID = 70001,@PPRODID = 10002

---------------------------------------------------------------------
GO
IF OBJECT_ID('GET_OPEN_ORDERS') IS NOT NULL
DROP PROCEDURE GET_OPEN_ORDERS;
GO


CREATE PROCEDURE GET_OPEN_ORDERS AS
BEGIN
 BEGIN TRY
    SELECT * FROM ORDER1522 WHERE DATETIMEDISPATCHED IS NULL        
 END TRY
 BEGIN CATCH
  BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
  END;  
 END CATCH
    -- RETURN A CURSOR WHICH REFERENCES ALL CURRENTLY OPEN (NOT FULFILLED) ORDERS

    -- EXCEPTIONS
    -- for any other errors throw error : number 50000  message:  error_message()
END;
GO
-----------------------------------------------------------------------------------------

  EXEC GET_OPEN_ORDERS;
 
-----------------------------------------------------------------------------------------

IF OBJECT_ID('FULLFILL_ORDER') IS NOT NULL
DROP PROCEDURE FULLFILL_ORDER;

GO


CREATE PROCEDURE FULLFILL_ORDER @PORDERID INT AS
BEGIN
 BEGIN TRANSACTION
  BEGIN TRY
     IF NOT EXISTS (SELECT * FROM ORDER1522 WHERE ORDERID = @PORDERID)
       THROW 54002,'ORDER DOES NOT EXIST',1
     IF (SELECT DATETIMEDISPATCHED FROM ORDER1522 WHERE ORDERID = @PORDERID) IS NOT NULL
       THROW 54003,'ORDER HAS ALRADY BEEN FULLFILLED',1
    UPDATE ORDER1522
    SET DATETIMEDISPATCHED = GETDATE()
    WHERE ORDERID = @PORDERID
    DECLARE @ORDERID INT,
    @PRODID INT,
    @QTY INT,
    @DISCOUNT DECIMAL(3,2),
    @SUBTOTAL MONEY,
    @PRODUCTID INT,
    @LOCID NVARCHAR(8),
    @NUMINSTOCK INT,
    @ORDERTOTAL MONEY,
    @USERID INT,
    @ACCOUNTID INT,
    @CREDITLIMIT MONEY,
    @BALANCE MONEY,
    @WHOLESALEVALUEOFORDER MONEY,
    @PRODUCTBUYPRICE MONEY;
    SET @WHOLESALEVALUEOFORDER = 0;
    SET @ORDERTOTAL = (SELECT TOTAL FROM ORDER1522 WHERE ORDERID = @PORDERID)
    SET @USERID = (SELECT USERID FROM ORDER1522 WHERE ORDERID = @PORDERID )
    SET @ACCOUNTID = (SELECT ACCOUNTID FROM AUTHORISEDPERSON1522 WHERE USERID = @USERID)
    DECLARE @FULLFILLORDERCURSOR CURSOR;
    SET @FULLFILLORDERCURSOR = CURSOR FOR SELECT * FROM ORDERLINE1522 WHERE ORDERID = @PORDERID;
    OPEN @FULLFILLORDERCURSOR
    FETCH NEXT FROM @FULLFILLORDERCURSOR INTO @ORDERID,@PRODID,@QTY,@DISCOUNT,@SUBTOTAL
    WHILE @@FETCH_STATUS = 0
     BEGIN   
     SET @PRODUCTBUYPRICE = (SELECT BUYPRICE FROM PRODUCT1522 WHERE PRODUCTID = @PRODID)
     SET @WHOLESALEVALUEOFORDER = @WHOLESALEVALUEOFORDER + (@PRODUCTBUYPRICE * @QTY)
     SELECT @WHOLESALEVALUEOFORDER
      DECLARE @FINDINVENTORYCURSOR CURSOR;
      SET @FINDINVENTORYCURSOR = CURSOR FOR SELECT * FROM INVENTORY1522 WHERE PRODUCTID = @PRODID
      OPEN @FINDINVENTORYCURSOR
      FETCH NEXT FROM @FINDINVENTORYCURSOR INTO @PRODUCTID,@LOCID,@NUMINSTOCK
      
      WHILE @@FETCH_STATUS = 0 AND @QTY > 0
       BEGIN
         IF @NUMINSTOCK > 0 
         BEGIN
            IF @QTY >= @NUMINSTOCK
                BEGIN
                  SET @QTY = @QTY - @NUMINSTOCK
                  UPDATE INVENTORY1522
                  SET NUMINSTOCK = 0
                  WHERE PRODUCTID = @PRODUCTID AND LOCATIONID = @LOCID
                END         
            ELSE
            BEGIN
              UPDATE INVENTORY1522
              SET NUMINSTOCK = NUMINSTOCK - @QTY
              WHERE PRODUCTID = @PRODUCTID AND LOCATIONID = @LOCID
              SET @QTY = 0
            END
         END

         FETCH NEXT FROM @FINDINVENTORYCURSOR INTO @PRODUCTID,@LOCID,@NUMINSTOCK  
        END   
        CLOSE @FINDINVENTORYCURSOR;
        DEALLOCATE @FINDINVENTORYCURSOR
      IF NOT @QTY = 0
       THROW 54006,'INSUFFUCIENT INVENTORY TO FULFILL',1
      FETCH NEXT FROM @FULLFILLORDERCURSOR INTO @ORDERID,@PRODID,@QTY,@DISCOUNT,@SUBTOTAL
    END
    CLOSE @FULLFILLORDERCURSOR;
    DEALLOCATE @FULLFILLORDERCURSOR

    UPDATE CLIENTACCOUNT1522
    SET BALANCE = BALANCE + @ORDERTOTAL
    WHERE ACCOUNTID = @ACCOUNTID

    UPDATE GENERALLEDGER1522
    SET AMOUNT = AMOUNT + @ORDERTOTAL
    WHERE ITEMID = 3

    UPDATE GENERALLEDGER1522
    SET AMOUNT = AMOUNT - @WHOLESALEVALUEOFORDER
    WHERE ITEMID = 2
  COMMIT TRANSACTION
  END TRY
  BEGIN CATCH
  ROLLBACK TRANSACTION
  IF ERROR_NUMBER() = 54006 OR ERROR_NUMBER() = 54002 OR ERROR_NUMBER() = 54003
  THROW
  IF ERROR_MESSAGE() LIKE '%CHK_CLIENTACCOUNT_BALANCE_CREDIT%'
   THROW 53005,'INSUFFICIENT CREDIT',1
  ELSE
  BEGIN                
     DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
     THROW 50000, @ERRORMESSAGE,1            
  END; 
  END CATCH

    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION

    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION
    -- IF IT HAS NOT BEEN FULLFILLED THEN

    -- UPDATE THE ORDERS DATETIMEDISPATCHED WITH THE CURRENT DATE TIME
    -- ** TRICKY** FOR EACH PRODUCT IN THE ORDER FIND INVENTORY WHICH HAS SUFFICIENT UNITS OF THE PRODUCT IN STOCK 
            -- AND DECREASE THE INVENTORY BY THE AMOUNT OF THE PRODUCT IN TH ORDER
    -- INCREASE THE RELEVANT CLIENTACCOUNTS BALANCE BY THE TOTAL VALUE OF THE ORDER
    -- INCREASE THE GENERAL LEDGER ACCOUNT ASSETS AMOUNT BY THE TOTAL VALUE OF THE ORDER
    -- ** TRICKY** DECREASE THE GENERAL LEDGER STOCK ASSESTS AMOUNT BY THE WHOLESALE (QTY * BUYPRICE) OF ALL THE PRODUCTS IN THE ORDER

    -- EXCEPTIONS
    -- INSUFFICIENT INVENTORY OF ONE OR MORE PRODUCTS TO FULFILL ORDER THROW ERROR 54006: INSUFFUCIENT INVENTORY TO FULFILL
	-- CLIENT ACCOUNT DOES NOT HAVE SUFFICIENT CREDIT REMAINING TO PAY FOR ORDER THROW ERROR 53005 : INSUFFICIENT CREDIT
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54003 : ORDER HAS ALREADY BEEN FULLFILLED
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()
END;
GO

--Gives a high credit limit to added account so the Procedure doesnt throw error 53005
-- UPDATE CLIENTACCOUNT1522
-- SET CREDITLIMIT = CREDITLIMIT + 10000
-- WHERE ACCOUNTID = 30002

--  EXEC FULLFILL_ORDER @PORDERID = 70002

-- SELECT * FROM ORDER1522
-- SELECT * FROM ORDERLINE1522
-- SELECT * FROM INVENTORY1522
-- SELECT * FROM AUTHORISEDPERSON1522
-- SELECT * FROM CLIENTACCOUNT1522
-- SELECT * FROM GENERALLEDGER1522

--###############################################################
-- BELLOW CODE IS AN EXAMPLE ONLY - IT IS NOT PART OF THE TASK
--###############################################################
/*

CREATE PROCEDURE ADD_LOCATION @PCUSTID INT, @PCUSTNAME NVARCHAR(100) AS
BEGIN    
    BEGIN TRY        
        IF @PCUSTID < 1 OR @PCUSTID > 499            
        THROW 50020, 'Customer ID out of range', 1        
        INSERT INTO CUSTOMER (CUSTID, CUSTNAME, SALES_YTD, STATUS)         
        VALUES (@PCUSTID, @PCUSTNAME, 0, 'OK');    
    END TRY    
    BEGIN CATCH        
        if ERROR_NUMBER() = 2627            
            THROW 50010, 'Duplicate customer ID', 1        
        ELSE IF ERROR_NUMBER() = 50020            
            THROW        
        ELSE            
            BEGIN                
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
                THROW 50000, @ERRORMESSAGE, 1            
            END;    
    END CATCH;
END;

GO

EXEC ADD_CUSTOMER @pcustid = 1, @pcustname = 'testdude2';
EXEC ADD_CUSTOMER @pcustid = 500, @pcustname = 'testdude3';select * from customer;

*/
